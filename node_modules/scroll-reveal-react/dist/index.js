"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Div: () => Div_default,
  Text: () => Text_default,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/Div.tsx
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var Div = (props) => {
  const divContainerRef = (0, import_react.useRef)(null);
  const divRef = (0, import_react.useRef)(null);
  const { type, duration = 1e3, delay = 100, triggerAt = 0.1 } = props;
  const [animate, setAnimate] = (0, import_react.useState)(false);
  const [once, setOnce] = (0, import_react.useState)(false);
  let CLASS_CONFIG = "";
  const styler = {
    "--duration": `${duration}ms`
  };
  switch (type) {
    case "fade":
      CLASS_CONFIG = "fade";
      break;
    case "flicker":
      CLASS_CONFIG = "flicker";
      break;
    case "zoom": {
      CLASS_CONFIG = props.hasBounce ? "zoom-bounce" : "zoom";
      CLASS_CONFIG += ` zoom-${props.pivot ? props.pivot : "center"}`;
      styler["--zoom"] = props.initialZoom;
      const bnc = props.initialZoom <= 1 ? props.bounceFactor ? props.bounceFactor : 1.1 : props.bounceFactor ? 1 / props.bounceFactor : 0.9;
      styler["--bounce-factor-up"] = bnc;
      styler["--bounce-factor-down"] = 1 / bnc;
      break;
    }
    case "flip":
      switch (props.direction) {
        case "left-right":
          CLASS_CONFIG = "flip-left-right";
          break;
        case "top-bottom":
          CLASS_CONFIG = "flip-top-bottom";
          break;
        default:
          break;
      }
      break;
    case "slide":
      CLASS_CONFIG = `slide slide-${props.origin}${props.hasMomentum ? "-skew" : ""}`;
      styler["--slide-distance"] = props.origin === "left" || props.origin === "top" ? props.distance ? `-${props.distance}%` : "-50%" : props.distance ? `${props.distance}%` : "50%";
      break;
    case "blur":
      CLASS_CONFIG = "blur";
      styler["--blur-amount"] = props.amount + "px";
      break;
    case "scale":
      CLASS_CONFIG = "scale";
      styler["--scale-anim-x"] = props.initialScale[0];
      styler["--scale-anim-y"] = props.initialScale[1];
      break;
    case "roll":
      CLASS_CONFIG = `roll roll-${props.direction}`;
      break;
    default:
      break;
  }
  const STYLE = styler;
  (0, import_react.useEffect)(() => {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = "./index.css";
    link.type = "text/css";
    document.head.appendChild(link);
  }, []);
  (0, import_react.useEffect)(() => {
    const observerOptions = {
      root: null,
      rootMargin: "0px",
      threshold: triggerAt
    };
    const observer = new IntersectionObserver(([objectDiv]) => {
      setTimeout(() => {
        setAnimate(objectDiv.isIntersecting);
      }, delay);
    }, observerOptions);
    observer.observe(divContainerRef.current);
    return () => observer.disconnect();
  }, [delay, triggerAt]);
  (0, import_react.useEffect)(() => {
    const config = animate ? CLASS_CONFIG : `scroll-not-in-port`;
    if (divContainerRef.current && divRef.current) {
      divRef.current.className = once ? "once-only" : config;
    }
    if (props.onlyOnce && animate)
      setTimeout(() => {
        setOnce(true);
      }, duration);
  }, [animate, CLASS_CONFIG, props.onlyOnce, once, duration]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref: divContainerRef, className: "react-scroll-animation-div", style: STYLE, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { ref: divRef, className: CLASS_CONFIG, children: props.children }) });
};
var Div_default = Div;

// src/Text.tsx
var import_react2 = require("react");
var import_jsx_runtime2 = require("react/jsx-runtime");
var Text = (props) => {
  const { type, delay = 100, triggerAt = 0.1 } = props;
  const textContainerRef = (0, import_react2.useRef)(null);
  const textRef = (0, import_react2.useRef)(null);
  const [content, setContent] = (0, import_react2.useState)(props.content.split(""));
  const [animate, setAnimate] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    if (type === "typewriter")
      setContent((c) => [...c, ""]);
  }, [type]);
  (0, import_react2.useEffect)(() => {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = "./index.css";
    link.type = "text/css";
    document.head.appendChild(link);
  }, []);
  const setTypewriterAnimation = (0, import_react2.useCallback)((delay2, cursor) => {
    let index = 0;
    const anim = setInterval(
      () => {
        const ele = document.getElementById(`react-scroll-char-${index}`);
        if (ele) {
          ele.classList.add("react-scroll-text-cursor");
          setTimeout(() => {
            if (ele.id === `react-scroll-char-${content.length - 1}`) {
              if (cursor) {
                ele.style.animation = "none";
                ele.style.opacity = "0";
              }
              ele.style.animation = "cursor 1.5s steps(1) infinite";
            } else
              ele.classList.remove("react-scroll-text-cursor");
          }, delay2);
          ele.classList.remove("hide");
        }
        index = index + 1;
        if (index === content.length) {
          if (props.hideCursor)
            textRef.current?.classList.remove("react-scroll-text-cursor");
          clearInterval(anim);
        }
      },
      delay2
    );
  }, [props, content.length]);
  const setFadeAnimation = (0, import_react2.useCallback)((delay2) => {
    let index = 0;
    const anim = setInterval(
      () => {
        const ele = document.getElementById(`react-scroll-char-${index}`);
        if (ele) {
          ele.style.animation = `fade ${delay2}ms linear`;
          ele.classList.remove("hide");
        }
        index = index + 1;
        if (index === content.length) {
          clearInterval(anim);
        }
      },
      delay2
    );
  }, [content.length]);
  const setRandomAnimation = (0, import_react2.useCallback)((randoms, delay2) => {
    let characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const { alphabetOnly, numberOnly } = props;
    if (alphabetOnly)
      characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    if (numberOnly)
      characters = "0123456789";
    const charactersLength = characters.length;
    let index = 0;
    const mainAnim = setInterval(() => {
      let ran = 0;
      const ele = document.getElementById(`react-scroll-char-${index}`);
      if (ele) {
        const temp = ele.innerText;
        if (ele)
          ele.classList.remove("hide");
        const anim = setInterval(() => {
          ele.innerText = characters.charAt(Math.floor(Math.random() * charactersLength));
          ran++;
          if (ran === randoms) {
            clearInterval(anim);
            ele.innerText = temp;
          }
        }, delay2);
      }
      index++;
      if (index === content.length) {
        clearInterval(mainAnim);
      }
    }, delay2 * randoms);
  }, [content.length, props]);
  const resetAnimation = (0, import_react2.useCallback)(() => {
    if (textRef.current)
      Array.from(textRef.current.children).forEach((element) => {
        element.classList.add("hide");
        element.style.animation = "none";
      });
  }, []);
  (0, import_react2.useEffect)(() => {
    const observerOptions = {
      root: null,
      rootMargin: "0px",
      threshold: triggerAt
    };
    const observer = new IntersectionObserver(([objectDiv]) => {
      setTimeout(() => {
        setAnimate(objectDiv.isIntersecting);
      }, delay);
    }, observerOptions);
    observer.observe(textContainerRef.current);
    return () => observer.disconnect();
  }, [delay, triggerAt]);
  (0, import_react2.useEffect)(() => {
    if (!animate) {
      resetAnimation();
      return;
    }
    switch (type) {
      case "typewriter":
        setTypewriterAnimation(
          props.latterDelay ? props.latterDelay : 100,
          props.hideCursor ? props.hideCursor : false
        );
        break;
      case "fade":
        setFadeAnimation(props.duration ? props.duration : 500);
        break;
      case "random":
        setRandomAnimation(
          props.randoms ? props.randoms : 5,
          props.duration ? props.duration : 100
        );
        break;
      default:
        break;
    }
  }, [
    animate,
    type,
    setTypewriterAnimation,
    setFadeAnimation,
    setRandomAnimation,
    resetAnimation,
    props
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { ref: textContainerRef, className: "react-scroll-animation-text", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { style: { display: "inline" }, ref: textRef, children: content.map((char, index) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    "span",
    {
      id: `react-scroll-char-${index}`,
      className: `react-scroll-anim-text-char hide`,
      children: char
    },
    index
  )) }) }) });
};
var Text_default = Text;

// src/index.ts
var ScrollReveal = { Div: Div_default, Text: Text_default };
var src_default = ScrollReveal;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Div,
  Text
});
//# sourceMappingURL=index.js.map